Basic RTL implementations :

1. ALU adder
2. Binary to Gray
3. Binary to OneHot
4. Gray to Binary
5. Comaprator
6. MUX in different styles
7. Flip Flops
8. Johnson counter
9. Ring counter
10. LUT
11. Latches
12. LFSR
13. 16x1 MUX structural modelling
14. PISO shift reg
15. PWM generator
16. Parity detector
17. Priority Encoder
18. SIPO shift register
19. Serial adder
20. Simple timer
21. Even Odd counter
22. Mod-10 counter
23. Up down counter
24. Edge detector
25. Variable swapping
26. Counter with load
27. Adder subtractor
28. 7-Seg to ASCII

Moderately difficult RTLs :

1. Round Robin Arbiter
2. Synchronous FIFO
3. ALU with flags
5. Gray counter
6. Dual Gray counter
7. GCD counter
8. Moore Machine
9. Multiplier
10. Priority arbiter
11. 32x32 Reg Bank
12. Sequence Detector without FSM
13. Sequence Detector Ex-1
14. Sequence Detector Ex-2
15. Sequence Detector Ex-3
16. Sequence Generator
17. Single port RAM

Complex RTL Designs :

1. Asynchronous FIFO
2. MIPS32 processor design
3. APB slave interface
4. Memory interface
5. APB master

========================================== TBD ================================================================

1. Memory interface
2. Simple UART Transmitter: Implement a basic UART (Universal Asynchronous Receiver-Transmitter) transmitter module.with configurable baud rate, parity checking, and data framing.
8. Simple UART Receiver: Design a basic UART receiver module that receives and decodes serial data.
9. Clock Divider: Create a clock divider that generates a slower clock signal from a given input clock., divide by 3 clk
10. Debounce Circuit: Implement a debouncing circuit for a single push-button input to ensure clean transitions.
11. APB master interface
12. APB slave interface
13. Digital PLL: Design a Phase-Locked Loop (PLL) that locks the output frequency to the input reference frequency with adjustable phase and frequency.
14. Cache Memory: Design a 4-way set-associative cache with a 16-entry cache size and implement cache read and write policies.
15. Floating-Point Unit: Create a basic floating-point arithmetic unit that supports addition and subtraction operations.
16. Bus Arbiter: Design a bus arbiter that manages access to a shared bus for multiple masters using a round-robin or priority-based scheme.
17. DMA Controller: Design a Direct Memory Access (DMA) controller that can transfer data between memory and peripherals without CPU intervention.
18. Cyclic Redundancy Check (CRC): Create a module that computes a CRC for error detection in data transmission.
19. Floating-Point Multiplication: Implement a floating-point multiplier that supports IEEE 754 single-precision floating-point format.
20. Configurable Logic Block (CLB): Create a configurable logic block with a flexible interconnect network that can be used to implement various combinational and sequential logic.
21. Error Detection and Correction (ECC): Create an ECC module that detects and corrects single-bit errors in memory.
22. JTAG Interface: Create a JTAG (Joint Test Action Group) interface for debugging and testing digital circuits.
23. Synchronous FIFO with Read/Write Pointers: Design a synchronous FIFO buffer with separate read and write pointers, and implement pointer management to prevent underflow and overflow.
24. AHB master interface
25. AHB Slave interface
26. AXI master interface
27. AXI slave interface
28. 26 more to come....



