Basic RTL implementations :

1. ALU adder
2. Binary to Gray
3. Binary to OneHot
4. Gray to Binary
5. Comaprator
6. MUX in different styles
7. Flip Flops
8. Johnson counter
9. Ring counter
10. LUT
11. Latches
12. LFSR
13. 16x1 MUX structural modelling
14. PISO shift reg
15. PWM generator
16. Parity detector
17. Priority Encoder
18. SIPO shift register
19. Serial adder
20. Simple timer
21. Even Odd counter
22. Mod-10 counter
23. Up down counter
24. Edge detector
25. Variable swapping
26. Counter with load
27. Adder subtractor
28. 7-Seg to ASCII

Moderately difficult RTLs :

1. Round Robin Arbiter
2. Synchronous FIFO
3. ALU with flags
5. Gray counter
6. Dual Gray counter
7. GCD counter
8. Moore Machine
9. Multiplier
10. Priority arbiter
11. 32x32 Reg Bank
12. Sequence Detector without FSM
13. Sequence Detector Ex-1
14. Sequence Detector Ex-2
15. Sequence Detector Ex-3
16. Sequence Generator
17. Single port RAM

Complex RTL Designs :

1. Asynchronous FIFO
2. MIPS32 processor design
3. APB slave interface
4. Memory interface
5. APB master
6. FIFO flush logic
7. UART System
9. Debounce circuit


========================================== TBD ================================================================


1. Clock Divider: Create a clock divider that generates a slower clock signal from a given input clock., divide by 3 clk
2. Digital PLL: Design a Phase-Locked Loop (PLL) that locks the output frequency to the input reference frequency with adjustable phase and frequency.
3. Cache Memory: Design a 4-way set-associative cache with a 16-entry cache size and implement cache read and write policies.
4. Floating-Point Unit: Create a basic floating-point arithmetic unit that supports addition and subtraction operations.
5. Bus Arbiter: Design a bus arbiter that manages access to a shared bus for multiple masters using a round-robin or priority-based scheme.
6. DMA Controller: Design a Direct Memory Access (DMA) controller that can transfer data between memory and peripherals without CPU intervention.
7. Cyclic Redundancy Check (CRC): Create a module that computes a CRC for error detection in data transmission.
8. Floating-Point Multiplication: Implement a floating-point multiplier that supports IEEE 754 single-precision floating-point format.
9. Configurable Logic Block (CLB): Create a configurable logic block with a flexible interconnect network that can be used to implement various combinational and sequential logic.
10. Error Detection and Correction (ECC): Create an ECC module that detects and corrects single-bit errors in memory.
11. JTAG Interface: Create a JTAG (Joint Test Action Group) interface for debugging and testing digital circuits.
12. Synchronous FIFO with Read/Write Pointers: Design a synchronous FIFO buffer with separate read and write pointers, and implement pointer management to prevent underflow and overflow.
13. AHB master interface
14. AHB Slave interface
15. AXI master interface
16. AXI slave interface

more to come....



